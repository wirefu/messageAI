//
//  Message.swift
//  MessageAI
//
//  Created by Gauntlet AI Team
//  Copyright Â© 2025 Gauntlet AI. All rights reserved.
//

import Foundation
import FirebaseFirestore

/// Represents a message in a conversation
struct Message: Codable, Identifiable, Equatable {
    /// Unique identifier
    let id: String

    /// ID of the conversation this message belongs to
    let conversationID: String

    /// ID of the message sender
    let senderID: String

    /// Message content
    var content: String

    /// When the message was created
    var timestamp: Date

    /// When the message was delivered to recipient
    var deliveredAt: Date?

    /// When the message was read by recipient
    var readAt: Date?

    /// Current delivery status
    var status: MessageStatus

    /// AI-powered suggestions for this message
    var aiSuggestions: AISuggestion?
    
    /// Whether this message was generated by AI
    var isAIGenerated: Bool = false
    
    /// AI sources for this message (for RAG context)
    var aiSources: [MessageSource]?
    
    /// AI metadata (tokens, cost, etc.)
    var aiMetadata: AIMetadata?

    /// Coding keys for Firestore mapping
    enum CodingKeys: String, CodingKey {
        case id
        case conversationID
        case senderID
        case content
        case timestamp
        case deliveredAt
        case readAt
        case status
        case aiSuggestions
        case isAIGenerated
        case aiSources
        case aiMetadata
    }
}

// MARK: - Firestore Extensions

extension Message {
    /// Converts message to Firestore dictionary
    /// - Returns: Dictionary representation for Firestore
    func toFirestore() -> [String: Any] {
        var data: [String: Any] = [
            FirebaseConstants.MessageFields.id: id,
            FirebaseConstants.MessageFields.conversationID: conversationID,
            FirebaseConstants.MessageFields.senderID: senderID,
            FirebaseConstants.MessageFields.content: content,
            FirebaseConstants.MessageFields.timestamp: Timestamp(date: timestamp),
            FirebaseConstants.MessageFields.status: status.rawValue
        ]

        if let deliveredAt = deliveredAt {
            data[FirebaseConstants.MessageFields.deliveredAt] = Timestamp(date: deliveredAt)
        }

        if let readAt = readAt {
            data[FirebaseConstants.MessageFields.readAt] = Timestamp(date: readAt)
        }

        if let aiSuggestions = aiSuggestions,
           let suggestionData = try? JSONEncoder().encode(aiSuggestions),
           let suggestionDict = try? JSONSerialization.jsonObject(with: suggestionData) as? [String: Any] {
            data[FirebaseConstants.MessageFields.aiSuggestions] = suggestionDict
        }
        
        data[FirebaseConstants.MessageFields.isAIGenerated] = isAIGenerated
        
        if let aiSources = aiSources,
           let sourcesData = try? JSONEncoder().encode(aiSources),
           let sourcesDict = try? JSONSerialization.jsonObject(with: sourcesData) as? [String: Any] {
            data[FirebaseConstants.MessageFields.aiSources] = sourcesDict
        }
        
        if let aiMetadata = aiMetadata,
           let metadataData = try? JSONEncoder().encode(aiMetadata),
           let metadataDict = try? JSONSerialization.jsonObject(with: metadataData) as? [String: Any] {
            data[FirebaseConstants.MessageFields.aiMetadata] = metadataDict
        }

        return data
    }

    /// Creates message from Firestore document
    /// - Parameter document: Firestore document snapshot
    /// - Returns: Message instance or nil if decoding fails
    static func from(document: DocumentSnapshot) -> Message? {
        guard let data = document.data() else { return nil }

        var aiSuggestions: AISuggestion?
        if let suggestionDict = data[FirebaseConstants.MessageFields.aiSuggestions] as? [String: Any],
           let suggestionData = try? JSONSerialization.data(withJSONObject: suggestionDict) {
            aiSuggestions = try? JSONDecoder().decode(AISuggestion.self, from: suggestionData)
        }
        
        var aiSources: [MessageSource]?
        if let sourcesDict = data[FirebaseConstants.MessageFields.aiSources] as? [String: Any],
           let sourcesData = try? JSONSerialization.data(withJSONObject: sourcesDict) {
            aiSources = try? JSONDecoder().decode([MessageSource].self, from: sourcesData)
        }
        
        var aiMetadata: AIMetadata?
        if let metadataDict = data[FirebaseConstants.MessageFields.aiMetadata] as? [String: Any],
           let metadataData = try? JSONSerialization.data(withJSONObject: metadataDict) {
            aiMetadata = try? JSONDecoder().decode(AIMetadata.self, from: metadataData)
        }

        return Message(
            id: document.documentID,
            conversationID: data[FirebaseConstants.MessageFields.conversationID] as? String ?? "",
            senderID: data[FirebaseConstants.MessageFields.senderID] as? String ?? "",
            content: data[FirebaseConstants.MessageFields.content] as? String ?? "",
            timestamp: (data[FirebaseConstants.MessageFields.timestamp] as? Timestamp)?.dateValue() ?? Date(),
            deliveredAt: (data[FirebaseConstants.MessageFields.deliveredAt] as? Timestamp)?.dateValue(),
            readAt: (data[FirebaseConstants.MessageFields.readAt] as? Timestamp)?.dateValue(),
            status: MessageStatus(
                rawValue: data[FirebaseConstants.MessageFields.status] as? String ?? ""
            ) ?? .sending,
            aiSuggestions: aiSuggestions,
            isAIGenerated: data[FirebaseConstants.MessageFields.isAIGenerated] as? Bool ?? false,
            aiSources: aiSources,
            aiMetadata: aiMetadata
        )
    }
}

// MARK: - Helpers

extension Message {
    /// Whether this message has been read
    var isRead: Bool {
        status == .read
    }

    /// Whether this message is from the current user
    /// - Parameter currentUserID: Current user's ID
    /// - Returns: True if message is from current user
    func isFromCurrentUser(_ currentUserID: String) -> Bool {
        senderID == currentUserID
    }
}
